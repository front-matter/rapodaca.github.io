<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Graphs from Scratch in Python | Depth-First</title>
    <link rel="alternate" href="/articles.atom" title="Depth-First" type="application/atom+xml">
    <link rel="stylesheet" href="/css/reset.css">
    <link rel="stylesheet" href="/css/global.css">
    <link rel="shortcut icon" href="/images/favicon.png">
    <link rel="me" href="https://fosstodon.org/@rapodaca">
      <meta name="twitter:card" content="summary">
      <meta name="twitter:site" content="@rapodaca">
      <meta name="twitter:creator" content="@rapodaca">
      <meta property="og:url" content="http://depth-first.com/articles/2022/01/26/graphs-from-scratch-in-python/">
      <meta property="og:title" content="Graphs from Scratch in Python">
      <meta property="og:description" content="Boiling the complexity of graphs down to a few methods, then implementing them.">
      <meta property="og:image" content="http://depth-first.com/images/posts/20220126/summary.png">
      <meta content="Boiling the complexity of graphs down to a few methods, then implementing them." name="description">
        <link rel="stylesheet" href="/css/document.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/article.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css">

  </head>
  <body>
    <header>
      <div class="wrapper">
        <div class="site-id"><a href="/">Depth-First</a></div>
        <nav>
          <ul>
            <li><a href="/articles/">Archive</a></li><li><a href="/about/">About</a></li>
          </ul>
        </nav>
      </div>
    </header>
    <main>
      <div class="wrapper">
            <article>
      <header>
        <h1>Graphs from Scratch in Python</h1>
        <p class="byline">By Richard L. Apodaca</p>
          <time datetime="2022-01-26T17:30:00Z">2022-01-26T17:30:00Z</time>
      </header>
      <p>Graphs are central to many areas of programming, so it's not surprising to find many general-purpose graph libraries. But these ready-made solutions sometimes lack the focus needed to solve specific problem well. Having hit this problem several times, I recently proposed a solution in the form of a <a href="/articles/2020/01/06/a-minimal-graph-api/">minimal graph API</a> with a <a href="/articles/2020/02/17/graphs-in-rust-introducting-graphcore/">Rust implementation</a>. The idea is to maximize reusability by distilling a graph's essence to the smallest possible set of methods.</p>
<p>This article extends the idea to Python. Because graphs draw from so many areas of computer science, they make excellent test subjects for the intermediate-level programming language student. Along these lines, this article touches on concepts including the Python data model, iterators, generators, list comprehension, abstract base classes, protocols, complexity analysis, and type hints. For those interested in code first, <a href="https://github.com/rapodaca/pygraph">a companion repository</a> is available at GitHub.</p>
<h2 id="aminimalgraphapi">A Minimal Graph API</h2>
<p>A graph can be viewed as a set of nodes and a set of pairwise relationships, or edges, between them. The simplest possible API for a graph would therefore contain just two operations: iterate all nodes and iterate all edges. However, such a spartan API would not support doing any of the things that make graphs interesting. What's needed in addition are operations for counting, testing membership, and testing connectivity. The following minimal set of graph operations is based on the one I <a href="/articles/2020/01/06/a-minimal-graph-api/">previously proposed</a>.</p>
<ol>
<li>Iterate all nodes.</li>
<li>Return the node count ("order").</li>
<li>Test whether any nodes are present ("empty").</li>
<li>Test whether a node is a present ("membership").</li>
<li>Iterate all edges.</li>
<li>Return the edge count ("size").</li>
<li>Test whether an edge exists ("connectivity").</li>
<li>Iterate the nodes connected to a given node ("neighborhood").</li>
<li>Return the count of nodes attached to a given node ("degree").</li>
<li>Return a debugging string.</li>
</ol>
<p>This set is provably complete in the sense that it supports the two fundamental operations: iterating nodes (1) and iterating edges (5). The set also includes convenience operations for counting items, testing connectivity, and membership. A Python object mapping the above operations to methods could be used within any solvable graph problem.</p>
<p>But isn't this API too narrow? Popular libraries offer graphs with far more than just ten methods. Keep in mind that the ten operations can be composed limitlessly. Especially useful combinations can be bundled into functions and distributed as a library.</p>
<p>Some problem domains require graphs with special capabilities. In my field, chemistry, graphs model molecular structure with nodes modeling atoms and edges modeling bonding relationships. In such applications, the minimal API can be extended. Restricting methods to those fundamental to the problem domain will yield a flexible, but lean result.</p>
<p>The idea of a "lean," or minimal, API may not seem important. After all, what difference does it make whether a function is attached to a class (as a method) or accepts a class instance (as a function)? That distinction will become clearer after addressing the question of reducing the minimal graph API to practice.</p>
<h2 id="agraphprotocol">A Graph Protocol</h2>
<p>Python has been described as a "protocol-oriented" language. A <em>protocol</em> is a collection of methods useful for some purpose. A similar idea can be found in many languages: Java has interfaces, C++ has abstract classes, and Rust has traits.</p>
<p>A protocol can be implicit in the sense that a function might assume that an argument supports a specific set of methods. This assumption might even be stated in the documentation, but that's the extent of it. The function behaves as if the methods are present. If they're not the interpreter raises a runtime error. This is called "<a href="https://en.wikipedia.org/wiki/Duck_typing">duck typing</a>."</p>
<p>It's also possible to define a protocol explicitly using the <code>Protocol</code> <a href="https://docs.python.org/3/library/typing.html">type hint</a>. This approach makes it easier to structure documentation. But more than this, an explicit protocol can be analyzed by Python type checkers. These type checkers can themselves be integrated into developer tools to reveal type errors before runtime. This way of working has a lot in common with <a href="/articles/2021/11/03/typed-javascript/">Typed Javascript</a>.</p>
<p>The following <code>Protocol</code> translates the minimum graph API to a Python Protocol.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Protocol, Tuple


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">graph</span><span class="hljs-params">(Protocol)</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-string">"""Return the node count."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span><span class="hljs-params">(self, id: int)</span> -&gt; bool:</span>
        <span class="hljs-string">"""Test whether a node is present."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-string">"""Iterate all nodes."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span> -&gt; str:</span>
        <span class="hljs-string">"""Return a debugging string."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iteredges</span><span class="hljs-params">(self)</span> -&gt; Iterator[Tuple[int, int]]:</span>
        <span class="hljs-string">"""Iterate all edges."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-string">"""Return the edge count."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterneighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-string">"""Iterate the neighbors of a node."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">degree</span><span class="hljs-params">(self, id: int)</span> -&gt; int:</span>
        <span class="hljs-string">"""Return the count of nodes attached to a node."""</span>
        ...

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_edge</span><span class="hljs-params">(self, sid: int, tid: int)</span> -&gt; bool:</span>
        <span class="hljs-string">"""Test whether an edge exists."""</span>
        ...
</code></pre>
<p>This protocol reflects a collection-centric view in which a <code>Graph</code> contains zero or more integer node identifiers ("ids"). Ids can be counted, tested for membership, and iterated by virtue of the <a href="https://docs.python.org/3/reference/datamodel.html#special-method-names">special methods</a> <code>__len__</code>, <code>__contains__</code>, and <code>__iter__</code>, respectively. A debug string is available through <code>__repr__</code>.</p>
<pre><code class="hljs python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_graph</span><span class="hljs-params">(graph: Graph)</span>:</span>
    <span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> graph:
        print(<span class="hljs-string">"Found node id"</span>, id)

    print(<span class="hljs-string">"Sorted node list"</span>, sorted(graph))
    print(<span class="hljs-string">"Unsorted node list"</span>, [id <span class="hljs-keyword">for</span> id <span class="hljs-keyword">in</span> graph])

    <span class="hljs-keyword">if</span> graph:
        print(<span class="hljs-string">"Graph is not empty."</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Graph is empty."</span>)

    <span class="hljs-keyword">if</span> <span class="hljs-number">42</span> <span class="hljs-keyword">in</span> graph:
        print(<span class="hljs-string">"So special!"</span>)
    <span class="hljs-keyword">else</span>:
        print(<span class="hljs-string">"Not so special."</span>)

    print(<span class="hljs-string">"Here I am"</span>, repr(graph))
</code></pre>
<p>This concept goes by the name of "data model." The Python data model links classes, special methods, built-in functions and types, and protocols into a cohesive whole. For an excellent treatment of this topic see this talk by <a href="https://twitter.com/dontusethiscode">James Powell</a>.</p>
<div class="videowrapper">
  <iframe src="https://www.youtube.com/embed/cKPlPJyQrt4" allowfullscreen=""></iframe>
</div>
<p>What remains of the <code>Graph</code> protocol is implemented without special methods, but with Python idioms and conventions in mind. For example, a simple way to reveal edges would be to return a list of tuples. But that's not what <code>Graph</code> does. Instead, it returns an iterator of tuples. As we'll see, this offers flexibility to implementors of <code>Graph</code>, without restricting the uses of the return value:</p>
<pre><code class="hljs python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">report_edges</span><span class="hljs-params">(graph: Graph)</span>:</span>
    <span class="hljs-keyword">for</span> sid, tid <span class="hljs-keyword">in</span> graph.iteredges():
        print(<span class="hljs-string">f"Found edge (<span class="hljs-subst">{sid}</span>, <span class="hljs-subst">{tid}</span>)."</span>)

    print(<span class="hljs-string">"A list of bonds:"</span>, list(graph.iteredges()))
</code></pre>
<p>The same applies to reporting neighbors:</p>
<pre><code class="hljs python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">report_neighbors</span><span class="hljs-params">(id: int, graph: Graph)</span>:</span>
    <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> graph.iterneighbors(id):
        print(<span class="hljs-string">f"Found neighbor <span class="hljs-subst">{tid}</span>."</span>)

    print(<span class="hljs-string">"A list of neighbors:"</span>, list(graph.iterneighbors(id)))
</code></pre>
<p>Bundled with <code>Graph</code> are five custom exceptions that are raised either in the context of constructing or using a <code>Graph</code>.</p>
<pre><code class="hljs python language-python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuplicateNode</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Raised when building a graph with duplicate nodes."""</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DuplicateEdge</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Raised when building a graph with duplicate edges."""</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Loop</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Raised when building a graph with with a loop."""</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnknownNode</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Raised when accessing a node whose id is not found."""</span>


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HalfEdge</span><span class="hljs-params">(Exception)</span>:</span>
    <span class="hljs-string">"""Raised when building an adjacency-style graph without a back edge."""</span>
</code></pre>
<p>Let's make this discussion of the <code>Graph</code> protocol more concrete with an implementation.</p>
<h2 id="adjacencylist">AdjacencyList</h2>
<p>An <a href="https://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a> is a graph implementation that associates each node with a list of neighbors. This pattern is implemented by the <code>AdjacencyList</code> class.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Tuple
<span class="hljs-keyword">from</span> pygraph.graph <span class="hljs-keyword">import</span> DuplicateEdge, HalfEdge, Loop, UnknownNode


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjacencyList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, adjacency: dict[int, list[int]])</span>:</span>
        <span class="hljs-keyword">for</span> sid, tids <span class="hljs-keyword">in</span> adjacency.items():
            <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> tids:
                <span class="hljs-keyword">try</span>:
                    sids = adjacency[tid]
                <span class="hljs-keyword">except</span> KeyError:
                    <span class="hljs-keyword">raise</span> UnknownNode

                <span class="hljs-keyword">if</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sids:
                    <span class="hljs-keyword">raise</span> HalfEdge
                <span class="hljs-keyword">elif</span> tids.count(tid) &gt; <span class="hljs-number">1</span>:
                    <span class="hljs-keyword">raise</span> DuplicateEdge
                <span class="hljs-keyword">elif</span> tid == sid:
                    <span class="hljs-keyword">raise</span> Loop

        self._adjacency = dict(adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span><span class="hljs-params">(self, id: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">return</span> id <span class="hljs-keyword">in</span> self._adjacency

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._adjacency.keys())

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span> -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'AdjacencyList({})'</span>.format(self._adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iteredges</span><span class="hljs-params">(self)</span> -&gt; Iterator[Tuple[int, int]]:</span>
        <span class="hljs-keyword">for</span> sid, tids <span class="hljs-keyword">in</span> self._adjacency.items():
            <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> tids:
                <span class="hljs-keyword">if</span> sid &lt; tid:
                    <span class="hljs-keyword">yield</span> (sid, tid)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterneighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> self.iteredges())

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">degree</span><span class="hljs-params">(self, id: int)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_edge</span><span class="hljs-params">(self, sid: int, tid: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">if</span> tid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">raise</span> UnknownNode

        <span class="hljs-keyword">return</span> tid <span class="hljs-keyword">in</span> self._neighbors(sid)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_neighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; list[int]:</span>
        <span class="hljs-keyword">try</span>:
            result = self._adjacency[id]
        <span class="hljs-keyword">except</span> KeyError:
            <span class="hljs-keyword">raise</span> UnknownNode

        <span class="hljs-keyword">return</span> result
</code></pre>
<p><code>AdjacencyList</code> is backed by a <code>dict[int, list[int]]</code>, or a mapping of node id to neighbor list. This data structure by itself offers a remarkably good match to the minimal graph API, as can be seen from the delegated methods <code>__len__</code>, <code>__contains__</code>, <code>__iter__</code>, <code>iterneighbors</code>, and <code>degree</code>.</p>
<p>The remaining methods illustrate mismatches between a raw dict and the minimal graph API. Take, for example, <code>iteredges</code>.</p>
<pre><code class="hljs python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iteredges</span><span class="hljs-params">(self)</span> -&gt; Iterator[Tuple[int, int]]:</span>
    <span class="hljs-keyword">for</span> sid, tids <span class="hljs-keyword">in</span> self._adjacency.items():
        <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> tids:
            <span class="hljs-keyword">if</span> sid &lt; tid:
                <span class="hljs-keyword">yield</span> (sid, tid)
</code></pre>
<p>The backing dict doesn't offer a direct method for edge iteration. Fortunately, a short <a href="https://wiki.python.org/moin/Generators">generator</a> can be used instead. No temporary collections (e.g, list or set) are required to avoid iterating non-unique edges. Instead, we use a trick that simply checks that the source id is less than the target id before yielding. This approach has the added advantage of always iterating edges in the same sense and direction.</p>
<p>Given that <code>AdjacencyList</code> uses a clone of the dict passed to it through the constructor, the <code>__init__</code> method may seem overly busy. What's happening here is a check to ensure that the dict does not contain any of the following bad encodings: a non-member neighbor; a half-edge (sid-&gt;tid without tid-&gt;sid); a duplicate edge; or a loop (edge to self).</p>
<pre><code class="hljs python language-python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, adjacency: dict[int, list[int]])</span>:</span>
    <span class="hljs-keyword">for</span> sid, tids <span class="hljs-keyword">in</span> adjacency.items():
        <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> tids:
            <span class="hljs-keyword">try</span>:
                sids = adjacency[tid]
            <span class="hljs-keyword">except</span> KeyError:
                <span class="hljs-keyword">raise</span> UnknownNode

            <span class="hljs-keyword">if</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sids:
                <span class="hljs-keyword">raise</span> HalfEdge
            <span class="hljs-keyword">elif</span> tids.count(tid) &gt; <span class="hljs-number">1</span>:
                <span class="hljs-keyword">raise</span> DuplicateEdge
            <span class="hljs-keyword">elif</span> tid == sid:
                <span class="hljs-keyword">raise</span> Loop

    self._adjacency = dict(adjacency)
</code></pre>
<p>Three methods, <code>iterneighbors</code>, <code>degree</code>, and <code>has_edge</code> call a private helper method, <code>_neighbors</code>. The sole purpose of doing so is to avoid the duplication that would result from transforming the built-in <code>KeyError</code> into the custom <code>UnknownNode</code> exception.</p>
<p>The sailing has been pretty smooth with <code>AdjacencyList</code>. Now let's consider an implementation that trades a simpler backing data type for a more complex implementation.</p>
<h2 id="edgelist">EdgeList</h2>
<p>An <a href="https://en.wikipedia.org/wiki/Edge_list">edge list</a> views a graph as a list of edges. <code>EdgeList</code> implements this idea.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Tuple
<span class="hljs-keyword">from</span> pygraph.graph <span class="hljs-keyword">import</span> DuplicateEdge, Loop, UnknownNode


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EdgeList</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, edges: list[Tuple[int, int]])</span>:</span>
        seen = set()

        <span class="hljs-keyword">for</span> (sid, tid) <span class="hljs-keyword">in</span> edges:
            <span class="hljs-keyword">if</span> (sid, tid) <span class="hljs-keyword">in</span> seen <span class="hljs-keyword">or</span> (tid, sid) <span class="hljs-keyword">in</span> seen:
                <span class="hljs-keyword">raise</span> DuplicateEdge
            <span class="hljs-keyword">elif</span> sid == tid:
                <span class="hljs-keyword">raise</span> Loop

            seen.add((sid, tid))

        self._edges = list(edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> self._nodes())

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span><span class="hljs-params">(self, id: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">for</span> sid, tid <span class="hljs-keyword">in</span> self._edges:
            <span class="hljs-keyword">if</span> id == sid <span class="hljs-keyword">or</span> id == tid:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._nodes())

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span> -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'EdgeList({})'</span>.format(self._edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iteredges</span><span class="hljs-params">(self)</span> -&gt; Iterator[Tuple[int, int]]:</span>
        <span class="hljs-keyword">return</span> iter(self._edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterneighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">degree</span><span class="hljs-params">(self, id: int)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_edge</span><span class="hljs-params">(self, sid: int, tid: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">if</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self <span class="hljs-keyword">or</span> tid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">raise</span> UnknownNode

        <span class="hljs-keyword">for</span> edge <span class="hljs-keyword">in</span> self._edges:
            <span class="hljs-keyword">if</span> edge[<span class="hljs-number">0</span>] == sid <span class="hljs-keyword">and</span> edge[<span class="hljs-number">1</span>] == tid:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
            <span class="hljs-keyword">elif</span> edge[<span class="hljs-number">1</span>] == sid <span class="hljs-keyword">and</span> edge[<span class="hljs-number">0</span>] == tid:
                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_neighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">if</span> id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">raise</span> UnknownNode
        <span class="hljs-keyword">else</span>:
            <span class="hljs-keyword">return</span> self._mates(id)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_mates</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">for</span> sid, tid <span class="hljs-keyword">in</span> self._edges:
            <span class="hljs-keyword">if</span> id == sid:
                <span class="hljs-keyword">yield</span> tid
            <span class="hljs-keyword">elif</span> id == tid:
                <span class="hljs-keyword">yield</span> sid

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_nodes</span><span class="hljs-params">(self)</span> -&gt; Iterator[int]:</span>
        seen = set()

        <span class="hljs-keyword">for</span> sid, tid <span class="hljs-keyword">in</span> self._edges:
            <span class="hljs-keyword">if</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(sid)

                <span class="hljs-keyword">yield</span> sid

            <span class="hljs-keyword">if</span> tid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> seen:
                seen.add(tid)

                <span class="hljs-keyword">yield</span> tid
</code></pre>
<p>The main advantage of <code>EdgeList</code> is the simplicity and low cost of its backing store, which is just a <code>list[Tuple[int, int]]</code>. The main disadvantage is almost everything else. Although edges can be iterated and counted with pure delegation, the remaining methods require greater computational complexity.</p>
<p>These difficulties are such that <code>EdgeList</code> defines two private helper methods: <code>_neighbors</code>, a two part function-generator pair to to iterate the neighbors of a node; and <code>_nodes</code> to iterate the set of <code>Graph</code> member node ids.</p>
<p>The result is that certain method calls are more inefficient than they aught to be. Consider <code>__len__</code>. Just counting member nodes or testing membership has a time complexity of <em>O(n)</em>, where <em>n</em> is the number of edges.</p>
<p>Still, <code>EdgeList</code> offers the advantage of efficient operations over the set of all edges. Recall that this was something <code>AdjacencyList</code> wasn't very good at. Maybe it's possible to get the best of both worlds.</p>
<h2 id="hybrid">Hybrid</h2>
<p>The node-centered efficiency of <code>AdjacencyList</code> can be combined with the edge-centered efficiency of <code>EdgeList</code> with <code>Hybrid</code>. An instance of this class will be backed by both an adjacency list and an edge list generated from it.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Iterator, Tuple
<span class="hljs-keyword">from</span> pygraph.graph <span class="hljs-keyword">import</span> HalfEdge, Loop, UnknownNode


<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hybrid</span>:</span>
    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, adjacency: dict[int, list[int]])</span>:</span>
        self._edges = []

        <span class="hljs-keyword">for</span> sid, tids <span class="hljs-keyword">in</span> adjacency.items():
            <span class="hljs-keyword">for</span> tid <span class="hljs-keyword">in</span> tids:
                <span class="hljs-keyword">try</span>:
                    sids = adjacency[tid]
                <span class="hljs-keyword">except</span> KeyError:
                    <span class="hljs-keyword">raise</span> UnknownNode

                <span class="hljs-keyword">if</span> sid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> sids:
                    <span class="hljs-keyword">raise</span> HalfEdge
                <span class="hljs-keyword">elif</span> sid == tid:
                    <span class="hljs-keyword">raise</span> Loop
                <span class="hljs-keyword">elif</span> sid &lt; tid:
                    self._edges.append((sid, tid))

        self._adjacency = dict(adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__contains__</span><span class="hljs-params">(self, id: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">return</span> id <span class="hljs-keyword">in</span> self._adjacency

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(self)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._adjacency.keys())

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__repr__</span><span class="hljs-params">(self)</span> -&gt; str:</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">'Hybrid({})'</span>.format(self._adjacency)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iteredges</span><span class="hljs-params">(self)</span> -&gt; Iterator[Tuple[int, int]]:</span>
        <span class="hljs-keyword">return</span> iter(self._edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">size</span><span class="hljs-params">(self)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._edges)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">iterneighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; Iterator[int]:</span>
        <span class="hljs-keyword">return</span> iter(self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">degree</span><span class="hljs-params">(self, id: int)</span> -&gt; int:</span>
        <span class="hljs-keyword">return</span> len(self._neighbors(id))

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_edge</span><span class="hljs-params">(self, sid: int, tid: int)</span> -&gt; bool:</span>
        <span class="hljs-keyword">if</span> tid <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> self:
            <span class="hljs-keyword">raise</span> UnknownNode

        <span class="hljs-keyword">return</span> tid <span class="hljs-keyword">in</span> self._neighbors(sid)

    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_neighbors</span><span class="hljs-params">(self, id: int)</span> -&gt; list[int]:</span>
        <span class="hljs-keyword">try</span>:
            result = self._adjacency[id]
        <span class="hljs-keyword">except</span> KeyError:
            <span class="hljs-keyword">raise</span> UnknownNode

        <span class="hljs-keyword">return</span> result
</code></pre>
<p>The main difference with <code>AdjacencyList</code> is that <code>Hybrid</code> stores a list of edges, simplifying the implementation of <code>iteredges</code> and <code>size</code>, and decreasing the time complexity of <code>size</code> to <em>O(1)</em>.</p>
<h2 id="whitherabstractbaseclasses">Whither Abstract Base Classes?</h2>
<p>There's one other way to make a protocol explicit: an <a href="https://docs.python.org/3/library/abc.html">Abstract Base Class</a> (ABC). An ABC is a class that defines one or more abstract methods to be implemented by subclasses.</p>
<p>It's possible to declare <code>Graph</code> as an ABC like so.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Graph</span><span class="hljs-params">(ABC)</span>:</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>The distinction between <code>Protocol</code> and <code>ABC</code> is both subtle and important. A <code>Protocol</code> requires nothing from a conforming class other than a set of methods. An ABC, on the other hand, requires an inheritance relationship.</p>
<pre><code class="hljs python language-python"><span class="hljs-keyword">from</span> pygraph <span class="hljs-keyword">import</span> Graph

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteGraph</span><span class="hljs-params">(Graph)</span>:</span>
    <span class="hljs-comment"># method overrides</span>
    <span class="hljs-keyword">pass</span>
</code></pre>
<p>Under ABC, a class can implement all <code>Graph</code> methods and still be rejected by the type checker if it fails to also inherit from <code>Graph</code>. Using Protocol, however, any class with a conforming interface will be considered a valid <code>Graph</code>.</p>
<p>I bring this up because of the unfortunate fact of graph life that many algorithms are computationally demanding. One way to improve performance is to implement those algorithms in a fast language such as C, C++, or Rust. (I'll have more to say about <code>Graph</code> and Rust in future articles.) Depending on the tooling around that low-level implementation, it may not be feasible to ensure an inheritance relationship with a <code>graph</code> ABC. For now, the advantage goes to Protocol.</p>
<h2 id="othergraphimplementations">Other Graph Implementations</h2>
<p>It may not seem like it, but there's a lot more to implementing <code>Graph</code> than what's been discussed here. That's because there are so many different kinds of graphs. Consider a <a href="/articles/2019/04/02/the-maximum-matching-problem/">matching</a>, which is a graph in which every node has degree one. An <code>AdjacencyList</code> would certainly do the job, but it would be overkill. A backing <code>dict[int, int]</code> would do the job more efficiently and simply. Similar considerations apply for other specialized graphs.</p>
<p>Higher complexity is also possible. This article doesn't deal with the topic of loops, parallel edges or directed edges. Although the minimal graph API is compatible with them, concrete implementations may not be. This can lead to conflict should, for example, a function accepting a <code>Graph</code> as an argument assume that loops are disallowed whereas an implementation does not. For this reason, a <code>Graph</code> Protocol must declare its assumptions about disallowed graph features so that subclasses can behave accordingly.</p>
<h2 id="consistencyandcohesion">Consistency and Cohesion</h2>
<p>The existence of a <code>Graph</code> Protocol makes it possible to write code that works with a well-defined interface, disregarding any and all implementation details of the underlying graph object. This article has outlined some clear advantages with regard to Python, but there's more to it than that. Graph capabilities factor prominently in the early stages of problem formulation. Even pseudocode uses a graph API, although it may not be defined anywhere. Graphs are, of course, used within every programming language. A common set of capabilities across all of the contexts in which graphs appear can benefit not just specific implementations, but designs and ideas.</p>
<p>A simple language around graph capabilities, used consistently, offers cohesion and reuse potential that's hard to achieve otherwise.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Although graph theory is a complex topic, the behavior of graph-like objects need not be. Just ten operations suffice to define all of the behaviors associated with graphs. Codifying these behaviors as a <code>Python</code> protocol allows functions to focus on fundamental behaviors rather than implementation idiosyncrasies. Limiting the scope of the <code>Graph</code> protocol makes multiple special-purpose implementations practical. More broadly, a common vocabulary around graph behavior means that concepts, algorithms, and designs developed on one platform can readily be adapted to others.</p>
    </article>

      </div>
    </main>
    <footer>
      <ul>
        <li>&copy; 2006-2024<li><a href="https://creativecommons.org/licenses/by/2.0/">CC-BY</a></li><li><a href="/about/">Richard L. Apodaca</a></li><li><a href="/articles.atom">Feed</a></li>
      </ul>
    </footer>
    <script src="/js/moment.js"></script>
    <script src="/js/timestamps.js"></script>
    <script src="/js/analytics.js"></script>
  </body>
</html>